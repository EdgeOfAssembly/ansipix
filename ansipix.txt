.ansipix File Format Specification
===================================

Version: 1.0
Date: 2025-10-06
Author: EdgeOfAssembly (based on ansipix program design)

Overview
--------

The .ansipix file format is a binary/text hybrid designed for storing and replaying ANSI art (text-based images and animations) generated by the ansipix terminal renderer. It is self-contained, preserving metadata for correct viewing across terminals with varying font sizes and pixel dimensions. The format prioritizes simplicity, portability, and efficiency, using a fixed binary header followed by human-readable JSON metadata and raw ANSI frame data.

This format is intended for sharing terminal art in a replayable way, avoiding issues with plain .ans files (e.g., lack of metadata for aspect ratio and timing). It supports static images, animated GIFs, and videos rendered as ANSI sequences.

File Structure
--------------

The file consists of the following sections in order (all data is UTF-8 encoded):

1. Magic String (8 bytes)
   - Fixed header for format identification.
   - Value: "ANSIPIX\x00" (null-terminated C-style string for safety).
   - Purpose: Allows quick detection of .ansipix files. If this string is not present, the file is invalid.

2. Version (4 bytes)
   - Little-endian unsigned 32-bit integer representing the format version.
   - Current value: 1 (0x01000000 in hex).
   - Purpose: Enables backward compatibility. Future versions may add fields or change structure; parsers should check this value.

3. Metadata Length (4 bytes)
   - Little-endian unsigned 32-bit integer indicating the byte length of the following JSON metadata string.
   - Purpose: Allows parsers to skip or read the metadata section without assuming a delimiter.

4. Metadata (variable length, as specified by Metadata Length)
   - A compact JSON string (no whitespace) containing replay-critical information.
   - Required fields (all must be present):
     - "version": Integer matching the Version field (for redundancy).
     - "rows": Integer, terminal height in lines (characters, not pixels).
     - "cols": Integer, terminal width in columns (characters, not pixels).
     - "color_depth": Integer, bits per pixel (24 for truecolor, 8 for 256-color dithered).
     - "frame_count": Integer, number of frames (1 for static, >1 for animated).
     - "fps": Float or null, frames per second (for videos; null/omitted for static/GIFs).
     - "durations": Array of floats, frame durations in seconds (length must equal frame_count; for GIFs/videos).
     - "loop": Integer, loop count (0 for infinite).
   - Example (formatted for readability; stored as one line):
     {
       "version": 1,
       "rows": 34,
       "cols": 120,
       "color_depth": 24,
       "frame_count": 1,
       "fps": null,
       "durations": [0.0],
       "loop": 0
     }
   - Purpose: Provides all data needed for correct replay. "rows" and "cols" are logical character dimensions; pixel dimensions are recalculated from the viewer's current font on playback.

5. Frame Data (variable length, until end of file)
   - Concatenated ANSI escape code strings, one per frame.
   - Each frame is a full ANSI sequence representing the rendered art (including backgrounds, effects, and dithering already applied).
   - Frames are separated by a single newline character (\n, 0x0A).
   - For static images: One frame only.
   - For animations: Multiple frames in order.
   - No compression or encoding; raw text for simplicity and readability.
   - Purpose: Direct output for terminal replay. On playback, load metadata to set terminal size/timing, then print frames with appropriate delays.

Design Rationale
----------------

- **Character-Based Dimensions**: Storing "rows" and "cols" (logical terminal size) ensures portability. Pixel dimensions vary by font (e.g., 8x16 vs. 14x28), so playback recalculates pixels from the current font and scales the art accordingly.
- **JSON Metadata**: Human-readable, extensible, and easy to parse in Python (via json.loads). Length prefix allows efficient seeking in large files.
- **Binary Header**: Enables fast format detection and version checks without parsing the entire file.
- **No Compression**: Keeps the format simple and debuggable. For large animations, users can compress the file externally (e.g., via gzip).
- **Self-Contained**: No external dependencies; all data for replay is embedded.
- **Extensibility**: New metadata fields can be added in future versions (bump the version number). Parsers should ignore unknown fields gracefully.
- **Edge Cases**:
  - If frame_count == 1 but durations has multiple entries, treat as static and ignore extra durations.
  - If fps is provided but durations is empty/null, fall back to fps-based timing.
  - Invalid JSON or missing required fields: Treat file as corrupt.
  - Very large files: No built-in limits; rely on filesystem/parsers.

Playback Implementation Notes
-----------------------------

To load and play a .ansipix file in ansipix.py:
1. Read magic string; if not "ANSIPIX\x00", error.
2. Read version; if >1, warn about potential incompatibility.
3. Read metadata length, then parse JSON metadata.
4. Read remaining file as frame data, split on \n into frames array.
5. Use metadata["cols"] x metadata["rows"] to determine the logical display dimensions of the art (do not attempt to resize the terminal, as this is not possible).
6. For each frame:
   - Clear screen and print the ANSI string.
   - Wait based on durations[i] (or 1/fps if durations is null).
7. Loop as per metadata["loop"] (0 = infinite).

This ensures fidelity to the original render. Test with various terminals to confirm font scaling.

Version History
---------------

- v1.0 (2025-10-06): Initial specification, as designed in todo.txt discussion.

License and Usage
-----------------

This specification is part of the ansipix program, released under [insert license, e.g., MIT]. Use freely for compatible implementations, but credit the original design.